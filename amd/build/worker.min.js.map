{"version":3,"file":"worker.min.js","sources":["../src/worker.js"],"sourcesContent":["/**\n * Real time eventsc\n *\n * @module     rtcomms_phppollshared/worker\n * @copyright  2024 Darren Cocco\n */\ndefine(['rtcomms_phppoll/realtime', 'core/pubsub', 'local_rtcomms/events', 'local_webworkers/web_worker'],\n    function(phpPoll, PubSub, RealTimeEvents, webWorker) {\n    return {\n        init: function() {\n            let portMap = new Map();\n            let portToChannelMap = {};\n            let channelToPortMap = {};\n            let channelBacklog = [];\n            let phpPollInitialised = false;\n            self.addEventListener('connect', (e) => {\n                const port = e.ports[0];\n\n                let clientId = portNumber.next().value;\n                port.clientId = clientId;\n                portMap.set(clientId, port);\n                portToChannelMap[clientId] = [];\n\n                port.addEventListener(\"message\", handleClientMessage(port.clientId));\n                port.start();\n            });\n\n            let handleMessage = (clientId, e) => {\n                let port = getClientPort(clientId);\n                if(port === undefined){\n                    return;\n                }\n                switch(e.data.type) {\n                    case 'configure':\n                        if(!phpPollInitialised) {\n                            setupPolling(e.data.configuration);\n                        }\n                        break;\n                    case 'listen':\n                        // TODO: should probably add some data validation here.\n                        if(!hasChannel(port, getChannelName(e.data.channel))) {\n                            addChannel(port, e.data.channel);\n                        }\n                        break;\n                    case 'close':\n                        cleanupPort(port.clientId);\n                        delete port.clientId;\n                        break;\n                    case 'ping':\n                        port.postMessage({type: 'pong'});\n                        break;\n                    case 'send':\n                        sendToServer(e.data);\n                        break;\n                    default:\n                        // TODO: Return better error message.\n                        port.postMessage('error');\n                        break;\n                }\n            };\n\n            let handleClientMessage = (clientId) => {\n                return (e) => {\n                    return handleMessage(clientId, e);\n                };\n            };\n\n            let serverMessageHandler = function(message) {\n                let channelName = _getChannelNameFromMessage(message);\n                if(channelToPortMap.hasOwnProperty(channelName)) {\n                    channelToPortMap[channelName].forEach((clientId) => {\n                        getClientPort(clientId)?.postMessage({ type: 'message', message: message});\n                    });\n                }\n            };\n\n\n            /**\n             * Gets channel name from message data format.\n             * @param {object} message\n             * @returns {string}\n             * @private\n             */\n            function _getChannelNameFromMessage(message) {\n                return getChannelName({\n                    context: message.context.id,\n                    component: message.component,\n                    area: message.area,\n                    itemid: message.itemid,\n                });\n            }\n\n            /**\n             *\n             * @param {int} clientId\n             * @returns {MessagePort}\n             */\n            function getClientPort(clientId) {\n                return portMap.get(clientId);\n            }\n\n            /**\n             *\n             * @param {MessagePort} port\n             * @param {string} channelName\n             * @returns {boolean}\n             */\n            function hasChannel(port, channelName) {\n                return portToChannelMap[port.clientId].includes(channelName);\n            }\n\n            /**\n             *\n             * @param {MessagePort} port\n             * @param {Object} channel\n             */\n            function addChannel(port, channel) {\n                let channelName = getChannelName(channel);\n                portToChannelMap[port.clientId].push(channelName);\n                if(!channelToPortMap.hasOwnProperty(channelName)) {\n                    channelToPortMap[channelName] = [];\n                    PubSub.subscribe(channelName, serverMessageHandler);\n                }\n                channelToPortMap[channelName].push(port.clientId);\n                if(phpPoll === null) {\n                    channelBacklog.push(channel);\n                } else {\n                    phpPoll.subscribe();\n                }\n            }\n\n            /**\n             * Remove ports and channel associations\n             * @param {string} clientId\n             */\n            function cleanupPort(clientId) {\n                delete portMap[clientId];\n                portToChannelMap['clientId'].forEach((channel) => {\n                    let index = channelToPortMap[channel].indexOf(clientId);\n                    channelToPortMap[channel].splice(index, 1);\n                });\n                delete portToChannelMap[clientId];\n            }\n\n            /**\n             * Generates a sequential set of numbers for the\n             * lifetime of the worker.\n             * @returns {Generator<number, void, *>}\n             */\n            function* generatePortNumber() {\n                const start = 0;\n                const end = Infinity;\n                const step = 1;\n                for (let i = start; i < end; i += step) {\n                    yield i;\n                }\n            }\n            let portNumber =  generatePortNumber();\n\n            /**\n             *\n             * @param {Object} configuration\n             */\n            function setupPolling(configuration) {\n                phpPollInitialised = true;\n                phpPoll.init(configuration);\n                if(channelBacklog.length > 0) {\n                    phpPoll.subscribe();\n                }\n            }\n\n            /**\n             *\n             * @param {Object} channelData\n             * @returns {string}\n             */\n            function getChannelName(channelData) {\n                return RealTimeEvents.EVENT + '/' + channelData.context + '/' + channelData.component + '/'\n                    + channelData.area + '/' + channelData.itemid;\n            }\n\n            /**\n             *\n             * @param {Object} data\n             * @returns void\n             */\n            function sendToServer(data) {\n                phpPoll.sendToServer(data.contextId, data.component, data.area, data.itemId, data.payload);\n            }\n\n            webWorker.workerSetupComplete();\n        }\n    };\n});"],"names":["define","phpPoll","PubSub","RealTimeEvents","webWorker","init","portMap","Map","portToChannelMap","channelToPortMap","channelBacklog","phpPollInitialised","self","addEventListener","e","port","ports","clientId","portNumber","next","value","set","handleClientMessage","start","handleMessage","getClientPort","data","configuration","undefined","type","length","subscribe","channelName","includes","hasChannel","getChannelName","channel","push","hasOwnProperty","serverMessageHandler","addChannel","forEach","index","indexOf","splice","cleanupPort","postMessage","sendToServer","contextId","component","area","itemId","payload","message","context","id","itemid","_getChannelNameFromMessage","get","i","Infinity","generatePortNumber","channelData","EVENT","workerSetupComplete"],"mappings":"AAMAA,sCAAO,CAAC,2BAA4B,cAAe,uBAAwB,gCACvE,SAASC,QAASC,OAAQC,eAAgBC,iBACnC,CACHC,KAAM,eACEC,QAAU,IAAIC,IACdC,iBAAmB,GACnBC,iBAAmB,GACnBC,eAAiB,GACjBC,oBAAqB,EACzBC,KAAKC,iBAAiB,WAAYC,UACxBC,KAAOD,EAAEE,MAAM,OAEjBC,SAAWC,WAAWC,OAAOC,MACjCL,KAAKE,SAAWA,SAChBX,QAAQe,IAAIJ,SAAUF,MACtBP,iBAAiBS,UAAY,GAE7BF,KAAKF,iBAAiB,UAAWS,oBAAoBP,KAAKE,WAC1DF,KAAKQ,eAGLC,cAAgB,CAACP,SAAUH,SACvBC,KAAOU,cAAcR,cA8JPS,KAvBAC,sBAtINC,IAATb,YAGID,EAAEY,KAAKG,UACL,YACGlB,qBAiIMgB,cAhIOb,EAAEY,KAAKC,cAiIhChB,oBAAqB,EACrBV,QAAQI,KAAKsB,eACVjB,eAAeoB,OAAS,GACvB7B,QAAQ8B,uBAjIH,mBAqEOhB,KAAMiB,oBACfxB,iBAAiBO,KAAKE,UAAUgB,SAASD,cApEpCE,CAAWnB,KAAMoB,eAAerB,EAAEY,KAAKU,oBA4EnCrB,KAAMqB,aAClBJ,YAAcG,eAAeC,SACjC5B,iBAAiBO,KAAKE,UAAUoB,KAAKL,aACjCvB,iBAAiB6B,eAAeN,eAChCvB,iBAAiBuB,aAAe,GAChC9B,OAAO6B,UAAUC,YAAaO,uBAElC9B,iBAAiBuB,aAAaK,KAAKtB,KAAKE,UACzB,OAAZhB,QACCS,eAAe2B,KAAKD,SAEpBnC,QAAQ8B,YAtFAS,CAAWzB,KAAMD,EAAEY,KAAKU,mBAG3B,kBA2FQnB,iBACVX,QAAQW,UACfT,iBAAgB,SAAaiC,SAASL,cAC9BM,MAAQjC,iBAAiB2B,SAASO,QAAQ1B,UAC9CR,iBAAiB2B,SAASQ,OAAOF,MAAO,aAErClC,iBAAiBS,UAhGhB4B,CAAY9B,KAAKE,iBACVF,KAAKE,mBAEX,OACDF,KAAK+B,YAAY,CAACjB,KAAM,mBAEvB,OAuISH,KAtIGZ,EAAEY,KAuIvBzB,QAAQ8C,aAAarB,KAAKsB,UAAWtB,KAAKuB,UAAWvB,KAAKwB,KAAMxB,KAAKyB,OAAQzB,KAAK0B,uBAnI1ErC,KAAK+B,YAAY,WAKzBxB,oBAAuBL,UACfH,GACGU,cAAcP,SAAUH,GAInCyB,qBAAuB,SAASc,aAC5BrB,qBAe4BqB,gBACzBlB,eAAe,CAClBmB,QAASD,QAAQC,QAAQC,GACzBN,UAAWI,QAAQJ,UACnBC,KAAMG,QAAQH,KACdM,OAAQH,QAAQG,SApBFC,CAA2BJ,SAC1C5C,iBAAiB6B,eAAeN,cAC/BvB,iBAAiBuB,aAAaS,SAASxB,qDACnCQ,cAAcR,oDAAW6B,YAAY,CAAEjB,KAAM,UAAWwB,QAASA,uBA0BpE5B,cAAcR,iBACZX,QAAQoD,IAAIzC,cA2DnBC,2BAJK,IAAIyC,EAHK,EAGMA,EAFRC,SAEiBD,GADhB,QAEHA,EAGIE,YAmBT1B,eAAe2B,oBACb3D,eAAe4D,MAAQ,IAAMD,YAAYR,QAAU,IAAMQ,YAAYb,UAAY,IAClFa,YAAYZ,KAAO,IAAMY,YAAYN,OAY/CpD,UAAU4D"}