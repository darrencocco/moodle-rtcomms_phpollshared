{"version":3,"file":"worker.min.js","sources":["../src/worker.js"],"sourcesContent":["/**\n * Real time eventsc\n *\n * @module     rtcomms_phppollshared/worker\n * @copyright  2024 Darren Cocco\n */\ndefine(['rtcomms_phppoll/realtime', 'core/pubsub', 'local_rtcomms/events', 'local_webworkers/web_worker'],\n    function(phpPoll, PubSub, RealTimeEvents, webWorker) {\n    return {\n        init: function() {\n            let portMap = new Map();\n            let portToChannelMap = {};\n            let channelToPortMap = {};\n            let channelBacklog = [];\n            let phpPollInitialised = false;\n            self.addEventListener('connect', (e) => {\n                const port = e.ports[0];\n\n                let clientId = portNumber.next().value;\n                port.clientId = clientId;\n                portMap.set(clientId, port);\n                portToChannelMap[clientId] = [];\n\n                port.addEventListener(\"message\", handleClientMessage(port.clientId));\n                port.start();\n            });\n\n            let handleMessage = (clientId, e) => {\n                let port = getClientPort(clientId);\n                if(port === undefined){\n                    return;\n                }\n                switch(e.data.type) {\n                    case 'configure':\n                        if(!phpPollInitialised) {\n                            setupPolling(e.data.configuration);\n                        }\n                        break;\n                    case 'listen':\n                        // TODO: should probably add some data validation here.\n                        if(!hasChannel(port, getChannelName(e.data.channel))) {\n                            addChannel(port, e.data.channel);\n                        }\n                        break;\n                    case 'close':\n                        cleanupPort(port.clientId);\n                        delete port.clientId;\n                        break;\n                    case 'ping':\n                        port.postMessage({type: 'pong'});\n                        break;\n                    default:\n                        // TODO: Return better error message.\n                        port.postMessage('error');\n                        break;\n                }\n            };\n\n            let handleClientMessage = (clientId) => {\n                return (e) => {\n                    return handleMessage(clientId, e);\n                };\n            };\n\n            let serverMessageHandler = function(message) {\n                let channelName = _getChannelNameFromMessage(message);\n                if(channelToPortMap.hasOwnProperty(channelName)) {\n                    channelToPortMap[channelName].forEach((clientId) => {\n                        getClientPort(clientId)?.postMessage({ type: 'message', message: message});\n                    });\n                }\n            };\n\n\n            /**\n             * Gets channel name from message data format.\n             * @param {object} message\n             * @returns {string}\n             * @private\n             */\n            function _getChannelNameFromMessage(message) {\n                return getChannelName({\n                    context: message.context.id,\n                    component: message.component,\n                    area: message.area,\n                    itemid: message.itemid,\n                });\n            }\n\n            /**\n             *\n             * @param {int} clientId\n             * @returns {MessagePort}\n             */\n            function getClientPort(clientId) {\n                return portMap.get(clientId);\n            }\n\n            /**\n             *\n             * @param {MessagePort} port\n             * @param {string} channelName\n             * @returns {boolean}\n             */\n            function hasChannel(port, channelName) {\n                return portToChannelMap[port.clientId].includes(channelName);\n            }\n\n            /**\n             *\n             * @param {MessagePort} port\n             * @param {Object} channel\n             */\n            function addChannel(port, channel) {\n                let channelName = getChannelName(channel);\n                portToChannelMap[port.clientId].push(channelName);\n                if(!channelToPortMap.hasOwnProperty(channelName)) {\n                    channelToPortMap[channelName] = [];\n                    PubSub.subscribe(channelName, serverMessageHandler);\n                }\n                channelToPortMap[channelName].push(port.clientId);\n                if(phpPoll === null) {\n                    channelBacklog.push(channel);\n                } else {\n                    phpPoll.subscribe();\n                }\n            }\n\n            /**\n             * Remove ports and channel associations\n             * @param {string} clientId\n             */\n            function cleanupPort(clientId) {\n                delete portMap[clientId];\n                portToChannelMap['clientId'].forEach((channel) => {\n                    let index = channelToPortMap[channel].indexOf(clientId);\n                    channelToPortMap[channel].splice(index, 1);\n                });\n                delete portToChannelMap[clientId];\n            }\n\n            /**\n             * Generates a sequential set of numbers for the\n             * lifetime of the worker.\n             * @returns {Generator<number, void, *>}\n             */\n            function* generatePortNumber() {\n                const start = 0;\n                const end = Infinity;\n                const step = 1;\n                for (let i = start; i < end; i += step) {\n                    yield i;\n                }\n            }\n            let portNumber =  generatePortNumber();\n\n            /**\n             *\n             * @param {Object} configuration\n             */\n            function setupPolling(configuration) {\n                phpPollInitialised = true;\n                phpPoll.init(configuration);\n                if(channelBacklog.length > 0) {\n                    phpPoll.subscribe();\n                }\n            }\n\n            /**\n             *\n             * @param {Object} channelData\n             * @returns {string}\n             */\n            function getChannelName(channelData) {\n                return RealTimeEvents.EVENT + '/' + channelData.context + '/' + channelData.component + '/'\n                    + channelData.area + '/' + channelData.itemid;\n            }\n\n            webWorker.workerSetupComplete();\n        }\n    };\n});"],"names":["define","phpPoll","PubSub","RealTimeEvents","webWorker","init","portMap","Map","portToChannelMap","channelToPortMap","channelBacklog","phpPollInitialised","self","addEventListener","e","port","ports","clientId","portNumber","next","value","set","handleClientMessage","start","handleMessage","getClientPort","configuration","undefined","data","type","length","subscribe","channelName","includes","hasChannel","getChannelName","channel","push","hasOwnProperty","serverMessageHandler","addChannel","forEach","index","indexOf","splice","cleanupPort","postMessage","message","context","id","component","area","itemid","_getChannelNameFromMessage","get","i","Infinity","generatePortNumber","channelData","EVENT","workerSetupComplete"],"mappings":"AAMAA,sCAAO,CAAC,2BAA4B,cAAe,uBAAwB,gCACvE,SAASC,QAASC,OAAQC,eAAgBC,iBACnC,CACHC,KAAM,eACEC,QAAU,IAAIC,IACdC,iBAAmB,GACnBC,iBAAmB,GACnBC,eAAiB,GACjBC,oBAAqB,EACzBC,KAAKC,iBAAiB,WAAYC,UACxBC,KAAOD,EAAEE,MAAM,OAEjBC,SAAWC,WAAWC,OAAOC,MACjCL,KAAKE,SAAWA,SAChBX,QAAQe,IAAIJ,SAAUF,MACtBP,iBAAiBS,UAAY,GAE7BF,KAAKF,iBAAiB,UAAWS,oBAAoBP,KAAKE,WAC1DF,KAAKQ,eAGLC,cAAgB,CAACP,SAAUH,SACvBC,KAAOU,cAAcR,cAoIPS,sBAnINC,IAATZ,YAGID,EAAEc,KAAKC,UACL,YACGlB,qBA8HMe,cA7HOZ,EAAEc,KAAKF,cA8HhCf,oBAAqB,EACrBV,QAAQI,KAAKqB,eACVhB,eAAeoB,OAAS,GACvB7B,QAAQ8B,uBA9HH,mBAkEOhB,KAAMiB,oBACfxB,iBAAiBO,KAAKE,UAAUgB,SAASD,cAjEpCE,CAAWnB,KAAMoB,eAAerB,EAAEc,KAAKQ,oBAyEnCrB,KAAMqB,aAClBJ,YAAcG,eAAeC,SACjC5B,iBAAiBO,KAAKE,UAAUoB,KAAKL,aACjCvB,iBAAiB6B,eAAeN,eAChCvB,iBAAiBuB,aAAe,GAChC9B,OAAO6B,UAAUC,YAAaO,uBAElC9B,iBAAiBuB,aAAaK,KAAKtB,KAAKE,UACzB,OAAZhB,QACCS,eAAe2B,KAAKD,SAEpBnC,QAAQ8B,YAnFAS,CAAWzB,KAAMD,EAAEc,KAAKQ,mBAG3B,kBAwFQnB,iBACVX,QAAQW,UACfT,iBAAgB,SAAaiC,SAASL,cAC9BM,MAAQjC,iBAAiB2B,SAASO,QAAQ1B,UAC9CR,iBAAiB2B,SAASQ,OAAOF,MAAO,aAErClC,iBAAiBS,UA7FhB4B,CAAY9B,KAAKE,iBACVF,KAAKE,mBAEX,OACDF,KAAK+B,YAAY,CAACjB,KAAM,uBAIxBd,KAAK+B,YAAY,WAKzBxB,oBAAuBL,UACfH,GACGU,cAAcP,SAAUH,GAInCyB,qBAAuB,SAASQ,aAC5Bf,qBAe4Be,gBACzBZ,eAAe,CAClBa,QAASD,QAAQC,QAAQC,GACzBC,UAAWH,QAAQG,UACnBC,KAAMJ,QAAQI,KACdC,OAAQL,QAAQK,SApBFC,CAA2BN,SAC1CtC,iBAAiB6B,eAAeN,cAC/BvB,iBAAiBuB,aAAaS,SAASxB,qDACnCQ,cAAcR,oDAAW6B,YAAY,CAAEjB,KAAM,UAAWkB,QAASA,uBA0BpEtB,cAAcR,iBACZX,QAAQgD,IAAIrC,cA2DnBC,2BAJK,IAAIqC,EAHK,EAGMA,EAFRC,SAEiBD,GADhB,QAEHA,EAGIE,YAmBTtB,eAAeuB,oBACbvD,eAAewD,MAAQ,IAAMD,YAAYV,QAAU,IAAMU,YAAYR,UAAY,IAClFQ,YAAYP,KAAO,IAAMO,YAAYN,OAG/ChD,UAAUwD"}