{"version":3,"file":"worker-lazy.min.js","sources":["../src/worker-lazy.js"],"sourcesContent":["/**\n * Real time events\n *\n * @module     rtcomms_phppollshared/worker\n * @copyright  2024 Darren Cocco\n */\ndefine(['rtcomms_phppoll/realtime', 'core/pubsub', 'tool_realtime/events'],\n    function(PhpPoll, PubSub, RealTimeEvents) {\n    let portMap = {};\n    let portToChannelMap = {};\n    let channelToPortMap = {};\n    let phpPoll = null;\n    let channelBacklog = [];\n    self.onconnect = (e) => {\n        const port = e.ports[0];\n\n        port.clientId = portNumber().next();\n        portMap[port.clientId] = port;\n        portToChannelMap[port.clientId] = [];\n\n        port.addEventListener(\"message\", (e) => {\n            if(!portIsAvailable(port)){\n                return;\n            }\n            switch(e.data.type) {\n                case 'configure':\n                    if(phpPoll === null) {\n                        setupPolling(e.data.configuration);\n                    }\n                    break;\n                case 'listen':\n                    // TODO: should probably add some data validation here.\n                    if(!hasChannel(port, channelName(e.data.channel))) {\n                        addChannel(port, e.data.channel);\n                    }\n                    break;\n                case 'close':\n                    cleanupPort(port.clientId);\n                    delete port.clientId;\n                    break;\n                default:\n                    // TODO: Return better error message.\n                    port.postMessage('error');\n                    break;\n            }\n        });\n\n        port.start();\n    };\n\n    let serverMessageHandler = function(message) {\n        let channelName = channelName(message);\n        if(channelToPortMap.hasOwnProperty(channelName)) {\n            channelToPortMap[channelName].forEach((portId) => {\n                portMap[portId].postMessage(message);\n            });\n        }\n    };\n\n    /**\n     *\n     * @param {int} port\n     * @returns {boolean}\n     */\n    function portIsAvailable(port) {\n        return port.hasOwnProperty('clientId');\n    }\n\n    /**\n     *\n     * @param {MessagePort} port\n     * @param {string} channelName\n     * @returns {boolean}\n     */\n    function hasChannel(port, channelName) {\n        return portToChannelMap[port.clientId].includes(channelName);\n    }\n\n    /**\n     *\n     * @param {MessagePort} port\n     * @param {Object} channel\n     */\n    function addChannel(port, channel) {\n        let channelName = channelName(channel);\n        portToChannelMap[port.clientId].push(channelName);\n        if(!channelToPortMap.hasOwnProperty(channelName)) {\n            channelToPortMap[channelName] = [];\n            PubSub.subscribe(channelName, serverMessageHandler);\n        }\n        channelToPortMap[channelName].push(port.clientId);\n        if(phpPoll === null) {\n            channelBacklog.push(channel);\n        } else {\n            phpPoll.subscribe(channel);\n        }\n    }\n\n    /**\n     * Remove ports and channel associations\n     * @param {string} clientId\n     */\n    function cleanupPort(clientId) {\n        delete portMap[clientId];\n        portToChannelMap['clientId'].forEach((channel) => {\n            let index = channelToPortMap[channel].indexOf(clientId);\n            channelToPortMap[channel].splice(index, 1);\n        });\n        delete portToChannelMap[clientId];\n    }\n\n    let _portNumber = null;\n    let portNumber = function() {\n        if(_portNumber !== null && _portNumber !== undefined) {\n            return _portNumber;\n        }\n        _portNumber = (function*() {\n            const start = 0;\n            const end = Infinity;\n            const step = 1;\n            for (let i = start; i < end; i += step) {\n                yield i;\n            }\n        });\n        return _portNumber;\n    };\n\n    /**\n     *\n     * @param {Object} configuration\n     */\n    function setupPolling(configuration) {\n        phpPoll = new PhpPoll();\n        phpPoll.init(configuration.userId, configuration.token, configuration.pollURLParam, configuration.maxDelay,\n            configuration.maxFailures, configuration.earliestMessageCreationTime, configuration.pollType);\n        if(channelBacklog.length > 0) {\n            channelBacklog.forEach((channel) => {\n                phpPoll.subscribe(channel.context, channel.component, channel.area, channel.itemid,\n                    channel.fromId, channel.fromTimestamp);\n            });\n            channelBacklog = [];\n        }\n    }\n\n    /**\n     *\n     * @param {Object} channelData\n     * @returns {string}\n     */\n    function channelName(channelData) {\n        return RealTimeEvents.EVENT + '/' + channelData.context + '/' + channelData.component + '/'\n            + channelData.area + '/' + channelData.itemid;\n    }\n});"],"names":["define","PhpPoll","PubSub","RealTimeEvents","portMap","portToChannelMap","channelToPortMap","phpPoll","channelBacklog","self","onconnect","e","port","ports","clientId","portNumber","next","addEventListener","channelData","configuration","hasOwnProperty","portIsAvailable","data","type","init","userId","token","pollURLParam","maxDelay","maxFailures","earliestMessageCreationTime","pollType","length","forEach","channel","subscribe","context","component","area","itemid","fromId","fromTimestamp","channelName","includes","hasChannel","EVENT","push","serverMessageHandler","addChannel","index","indexOf","splice","postMessage","start","message","portId","_portNumber","i","Infinity"],"mappings":"AAMAA,2CAAO,CAAC,2BAA4B,cAAe,yBAC/C,SAASC,QAASC,OAAQC,oBACtBC,QAAU,GACVC,iBAAmB,GACnBC,iBAAmB,GACnBC,QAAU,KACVC,eAAiB,GACrBC,KAAKC,UAAaC,UACRC,KAAOD,EAAEE,MAAM,GAErBD,KAAKE,SAAWC,aAAaC,OAC7BZ,QAAQQ,KAAKE,UAAYF,KACzBP,iBAAiBO,KAAKE,UAAY,GAElCF,KAAKK,iBAAiB,WAAYN,QAkFjBG,SA+CAI,YAlBCC,0BAnEGP,aACdA,KAAKQ,eAAe,YA5CnBC,CAAgBT,aAGbD,EAAEW,KAAKC,UACL,YACc,OAAZhB,UAyGGY,cAxGWR,EAAEW,KAAKH,cAyGpCZ,QAAU,IAAIN,QACdM,QAAQiB,KAAKL,cAAcM,OAAQN,cAAcO,MAAOP,cAAcQ,aAAcR,cAAcS,SAC9FT,cAAcU,YAAaV,cAAcW,4BAA6BX,cAAcY,UACrFvB,eAAewB,OAAS,IACvBxB,eAAeyB,SAASC,UACpB3B,QAAQ4B,UAAUD,QAAQE,QAASF,QAAQG,UAAWH,QAAQI,KAAMJ,QAAQK,OACxEL,QAAQM,OAAQN,QAAQO,kBAEhCjC,eAAiB,eA9GR,mBA4CGI,KAAM8B,oBACfrC,iBAAiBO,KAAKE,UAAU6B,SAASD,cA3ChCE,CAAWhC,MAqHVM,YArH4BP,EAAEW,KAAKY,QAsH7C/B,eAAe0C,MAAQ,IAAM3B,YAAYkB,QAAU,IAAMlB,YAAYmB,UAAY,IAClFnB,YAAYoB,KAAO,IAAMpB,YAAYqB,mBApE3B3B,KAAMsB,aAClBQ,YAAcA,YAAYR,SAC9B7B,iBAAiBO,KAAKE,UAAUgC,KAAKJ,aACjCpC,iBAAiBc,eAAesB,eAChCpC,iBAAiBoC,aAAe,GAChCxC,OAAOiC,UAAUO,YAAaK,uBAElCzC,iBAAiBoC,aAAaI,KAAKlC,KAAKE,UACzB,OAAZP,QACCC,eAAesC,KAAKZ,SAEpB3B,QAAQ4B,UAAUD,SA7DNc,CAAWpC,KAAMD,EAAEW,KAAKY,mBAG3B,QAkEIpB,SAjEOF,KAAKE,gBAkEtBV,QAAQU,UACfT,iBAAgB,SAAa4B,SAASC,cAC9Be,MAAQ3C,iBAAiB4B,SAASgB,QAAQpC,UAC9CR,iBAAiB4B,SAASiB,OAAOF,MAAO,aAErC5C,iBAAiBS,iBAtELF,KAAKE,uBAIZF,KAAKwC,YAAY,aAK7BxC,KAAKyC,aAGLN,qBAAuB,SAASO,aAC5BZ,YAAcA,YAAYY,SAC3BhD,iBAAiBc,eAAesB,cAC/BpC,iBAAiBoC,aAAaT,SAASsB,SACnCnD,QAAQmD,QAAQH,YAAYE,iBAyDpCE,YAAc,KACdzC,WAAa,kBACVyC,MAAAA,cAGHA,YAAe,gBAIN,IAAIC,EAHK,EAGMA,EAFRC,SAEiBD,GADhB,QAEHA,IAPHD"}